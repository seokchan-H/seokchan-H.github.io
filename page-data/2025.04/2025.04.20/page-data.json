{"componentChunkName":"component---src-templates-blog-post-js","path":"/2025.04/2025.04.20/","result":{"data":{"site":{"siteMetadata":{"title":"Dudeys Blog"}},"markdownRemark":{"id":"5dcb8a67-f412-5e65-9146-299aab802fb3","excerpt":"No. 결론부터 말하면 안 한다.\nPSQL 은 공식적으로 명시적인 락에서 FIFO 를 보장하지 않는다.\n(비공식적으로 FIFO 로 동작하지만 예외상황이 존재하기에 신뢰할 수 없다.) 사전 지식 PSQL 의 Lock 은 Tuple 를 기반으로 동작한다.\nPSQL…","html":"<p>No. 결론부터 말하면 안 한다.\nPSQL 은 공식적으로 명시적인 락에서 FIFO 를 보장하지 않는다.\n(비공식적으로 FIFO 로 동작하지만 예외상황이 존재하기에 신뢰할 수 없다.)</p>\n<h2>사전 지식</h2>\n<p>PSQL 의 Lock 은 Tuple 를 기반으로 동작한다.\nPSQL 은 데이터 수정시 새로운 Tuple 을 생성한다.\n만약 대기중인 Lock 들이 있다면 기존 Tuple 에 대한 점유를 포기하고\n신규 Tuple 에 대한 Lock 을 대기한다.</p>\n<h2>PSQL Community 조사</h2>\n<blockquote>\n<p>PSQL Community 에서는 Email 소통을 아카이빙하여 공유하고 있다.</p>\n</blockquote>\n<details open>\n<summary><a href=\"https://www.postgresql.org/message-id/flat/CANW1aT_Pc%2BxdoN_D-dK%2Bj3uE%2BD_2wfFZu26aAfprWsoGhoNu-A%40mail.gmail.com\">Are advisory locks guaranteed to be First Come First Serve? And can the behavior be relied upon?</a></summary>\n<blockquote>\n<p>기본적으로 FIFO 방식으로 동작한다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Yes - lock requests that block are queued, with later lock requests queued behind previous\nones.  Once a lock gets free, the first in line gets it.\n\nThis is the same for all heavyweight locks in PostgreSQL.</code></pre></div>\n<blockquote>\n<p>하지만 DeadLock 을 피하기 위해서 순서를 바꾸는 등의 예외는 존재한다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">There is an exception: the queue order will be rearranged if we find\nthat doing so is necessary to avoid a deadlock failure. \nSee src/backend/storage/lmgr/README</code></pre></div>\n</details>\n<details open>\n<summary><a href=\"https://www.postgresql.org/message-id/flat/TYAPR01MB607370A5022B8854EFDC1BA58AAD9%40TYAPR01MB6073.jpnprd01.prod.outlook.com\">The order of queues in row lock is changed (not FIFO)</a></summary>\n<blockquote>\n<p>Row 락 기반으로 업데이트 처리하는 트랜잭션을 여러개 수행한 테스트이다.\n수정시 신규 TID 에 락이 재정렬하게되고 이때 FIFO 가 보장되지 않는 내용이다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">I don't see a bug here, or at least I'm not willing to move the\ngoalposts to where you want them to be.  I believe that we do guarantee\narrival-order locking of individual tuple versions.  However, in the\nexample you show, a single row is being updated over and over.  So,\ninitially we have a single \"winner\" transaction that got the tuple lock\nfirst and updated the row.  When it commits, each other transaction\nserially comes off the wait queue for that tuple lock and discovers\nthat it now needs a lock on a different tuple version than it has got.\nSo it tries to get lock on whichever is the latest tuple version.\nThat might still appear serial as far as the original 100 sessions\ngo, because they were all queued on the same tuple lock to start with.\nBut when the new sessions come in, they effectively line-jump because\nthey will initially try to lock whichever tuple version is committed\nlive at that instant, and thus they get ahead of whichever remain of\nthe original 100 sessions for the lock on that tuple version (since\nthose are all still blocked on some older tuple version, whose lock is\nheld by whichever session is performing the next-to-commit update).\n\nI don't see any way to make that more stable that doesn't involve\nrequiring sessions to take locks on already-dead-to-them tuples;\nwhich sure seems like a nonstarter, not least because we don't even have\na way to find such tuples.  The update chains only link forward not back.</code></pre></div>\n</details>","frontmatter":{"title":"[PSQL] 락 순차 보장... 할까?","date":"April 19, 2025","description":null}},"previous":{"fields":{"slug":"/2025.04/2025.04.19/"},"frontmatter":{"title":"[PSQL] 트랜잭션 정합성 테스트"}},"next":null},"pageContext":{"id":"5dcb8a67-f412-5e65-9146-299aab802fb3","previousPostId":"ae3b729d-cded-573c-8a3b-338cba2fd6c8","nextPostId":null}},"staticQueryHashes":["2841359383","3257411868"],"slicesMap":{}}