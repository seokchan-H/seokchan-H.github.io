{"componentChunkName":"component---src-templates-blog-post-js","path":"/2025.04/2025.04.19/","result":{"data":{"site":{"siteMetadata":{"title":"Dudeys Blog"}},"markdownRemark":{"id":"ae3b729d-cded-573c-8a3b-338cba2fd6c8","excerpt":"…","html":"<p>정합성 관련해서 격리수준이나 락에 대한 표준이 있지만 데이터베이스별로 보장하는 수준이 다르다.\n표준은 최소 사양을 제시하고 데이터베이스들은 자신들의 기술력에 따라 같은 레벨이여도 더 높은 보장을 할 수 있다.\n이 얘기는 사용하는 데이터베이스에 따라 가장 효율적인 설정방식이 달라진다는 걸 뜻한다.\n이번엔 PSQL 에 대한 정합성 기준을 조사하고 정리해보자.</p>\n<h1>사전지식</h1>\n<blockquote>\n<p>테스트 전에 필요한 사전지식을 공유합니다.</p>\n</blockquote>\n<h2>격리수준</h2>\n<ul>\n<li>READ_UNCOMMITTED\n<ul>\n<li>다른 트랜잭션이 수정 중인 데이터를 읽을 수 있습니다.</li>\n<li>대부분의 DBMS 에서 지원하지 않습니다.</li>\n</ul>\n</li>\n<li>READ_COMMITTED\n<ul>\n<li>다른 트랜잭션이 커밋한 데이터만 읽을 수 있습니다.</li>\n</ul>\n</li>\n<li>REPEATABLE_READ\n<ul>\n<li>트랜잭션이 시작된 시점의 데이터를 읽습니다.</li>\n</ul>\n</li>\n<li>SERIALIZABLE\n<ul>\n<li>순차를 적용합니다.</li>\n<li>PSQL 은 Serializable Snapshot Isolation (SSI) 를 사용하고 충돌 시 rollback(후속 트랜잭션) 합니다.</li>\n</ul>\n</li>\n</ul>\n<h3>SQL 표준보다 강력한 PSQL 의 격리 수준</h3>\n<ul>\n<li><a href=\"https://www.postgresql.org/docs/current/transaction-iso.html#TRANSACTION-ISO\">공문 참조 (13.2. 트랜잭션 격리)</a></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Isolation Level</th>\n<th>Dirty Read</th>\n<th>Nonrepeatable Read</th>\n<th>Phantom Read</th>\n<th>Serialization Anomaly</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Read uncommitted</td>\n<td>Allowed, but not in PG</td>\n<td>Possible</td>\n<td>Possible</td>\n<td>Possible</td>\n</tr>\n<tr>\n<td>Read committed</td>\n<td>Not possible</td>\n<td>Possible</td>\n<td>Possible</td>\n<td>Possible</td>\n</tr>\n<tr>\n<td>Repeatable read</td>\n<td>Not possible</td>\n<td>Not possible</td>\n<td>Allowed, but not in PG</td>\n<td>Possible</td>\n</tr>\n<tr>\n<td>Serializable</td>\n<td>Not possible</td>\n<td>Not possible</td>\n<td>Not possible</td>\n<td>Not possible</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>PSQL 은 실제로 3가지 격리 수준만 구현되어 있습니다.\nPSQL 의 Read uncommitted 는 Read committed 처럼 동작합니다.\nPSQL 의 Repeatable read 는 Phantom Read 를 허용하지 않습니다.</p>\n</blockquote>\n<h3>직렬화 이상 (Serialization Anomaly)</h3>\n<table>\n<thead>\n<tr>\n<th>이상 현상 (Anomaly)</th>\n<th>설명</th>\n<th>Read Uncommitted</th>\n<th>Read Committed</th>\n<th>Repeatable Read</th>\n<th>Serializable</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Dirty Write</td>\n<td>커밋되지 않은 트랜잭션의 데이터를 읽고 덮어씀</td>\n<td>❌ 허용</td>\n<td>✅ 방지</td>\n<td>✅ 방지</td>\n<td>✅ 방지</td>\n</tr>\n<tr>\n<td>Dirty Read</td>\n<td>커밋되지 않은 트랜잭션의 데이터를 읽음</td>\n<td>❌ 허용</td>\n<td>✅ 방지</td>\n<td>✅ 방지</td>\n<td>✅ 방지</td>\n</tr>\n<tr>\n<td>Non-repeatable Read</td>\n<td>같은 데이터를 두 번 읽었는데 값이 바뀜</td>\n<td>❌ 허용</td>\n<td>❌ 허용</td>\n<td>✅ 방지</td>\n<td>✅ 방지</td>\n</tr>\n<tr>\n<td>Phantom Read</td>\n<td>같은 조건의 쿼리 결과가 반복 시 달라짐 (새 행 생김 등)</td>\n<td>❌ 허용</td>\n<td>❌ 허용</td>\n<td>❌ 허용</td>\n<td>✅ 방지</td>\n</tr>\n<tr>\n<td>Lost Update</td>\n<td>두 트랜잭션이 같은 데이터를 읽고 둘 다 업데이트 → 하나 덮어씀</td>\n<td>❌ 허용</td>\n<td>❌ 허용</td>\n<td>✅ 방지 (일부)</td>\n<td>✅ 방지</td>\n</tr>\n<tr>\n<td>Read Skew</td>\n<td>한 트랜잭션에서 읽은 값들이 서로 논리적으로 안 맞는 문제</td>\n<td>❌ 허용</td>\n<td>❌ 허용</td>\n<td>✅ 방지</td>\n<td>✅ 방지</td>\n</tr>\n<tr>\n<td>Write Skew</td>\n<td>서로 조건 만족 후 업데이트했지만 전체 논리적으로는 제약 위반</td>\n<td>❌ 허용</td>\n<td>❌ 허용</td>\n<td>❌ 허용</td>\n<td>✅ 방지</td>\n</tr>\n<tr>\n<td>Serialization Anomaly</td>\n<td>순차 실행으로는 절대 일어날 수 없는 결과</td>\n<td>❌ 허용</td>\n<td>❌ 허용</td>\n<td>❌ 허용</td>\n<td>✅ 방지</td>\n</tr>\n</tbody>\n</table>\n<h2>Spring Data JPA 설정방식</h2>\n<h3>락 유형</h3>\n<blockquote>\n<p>격리수준은 트랜잭션간의 영향도를 낮추는 방법이고\n락은 특정 데이터에 대한 접근을 제한하는 방법이다.</p>\n</blockquote>\n<h4>낙관락</h4>\n<blockquote>\n<p>어플리케이션 상에서 Lock 을 처리합니다.</p>\n</blockquote>\n<ul>\n<li>@Version 컬럼 지정</li>\n<li>OPTIMISTIC\n<ul>\n<li>수정시에만 @Version 이 증가된다.</li>\n<li>어플리케이션 레벨에서 Dirty Read 와 Non-repeatable Read 를 방지합니다.</li>\n</ul>\n</li>\n<li>OPTIMISTIC_FORCE_INCREMENT\n<ul>\n<li>OPTIMISTIC 기능 제공</li>\n<li>조회시에도 @Version 이 증가된다.</li>\n</ul>\n</li>\n</ul>\n<h4>비관락</h4>\n<blockquote>\n<p>DB 상의 Lock 을 사용합니다.</p>\n</blockquote>\n<ul>\n<li>PESSIMISTIC_READ\n<ul>\n<li>공유락 : 다른 트랜잭션이 읽을 수 있지만 수정은 불가</li>\n<li>(i.e. Shared Lock : for share)</li>\n</ul>\n</li>\n<li>PESSIMISTIC_WRITE\n<ul>\n<li>배타락 : 다른 트랜잭션이 읽기/쓰기 모두 불가</li>\n<li>(i.e. Exclusive Lock : for update)</li>\n</ul>\n</li>\n<li>낙관 + 비관락 병행\n<ul>\n<li>PESSIMISTIC_FORCE_INCREMENT</li>\n</ul>\n</li>\n</ul>\n<h3>Spring Transactional 애서 격리수준 설정하기</h3>\n<ul>\n<li>DEFAULT\n<ul>\n<li>데에터베이스의 기본 설정을 따른다.</li>\n<li>PSQL 은 READ_COMMITTED 을 기본으로 사용합니다.</li>\n</ul>\n</li>\n<li>READ_UNCOMMITTED</li>\n<li>READ_COMMITTED</li>\n<li>REPEATABLE_READ</li>\n<li>SERIALIZABLE</li>\n</ul>\n<blockquote>\n<p>Spring Data JPA 에서 테스트를 진행한다.</p>\n</blockquote>\n<h2>임계구역 경합 테스트</h2>\n<blockquote>\n<p>두 개의 트랜잭션에서 동일한 데이터를 수정하는 경우를 테스트합니다.</p>\n</blockquote>\n<h3>BeforeUpdate</h3>\n<ul>\n<li>A 트랜잭션 시작</li>\n<li>A 조회</li>\n<li><em><code class=\"language-text\">B 트랜잭션 시작</code></em></li>\n<li><em><code class=\"language-text\">B 조회</code></em></li>\n<li><em><code class=\"language-text\">A 수정</code></em></li>\n<li>B 수정</li>\n<li>A 트랜잭션 커밋</li>\n<li>B 트랜잭션 커밋</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>LockType \\ Isolation Level</th>\n<th><code class=\"language-text\">READ_UNCOMMITTED</code></th>\n<th><code class=\"language-text\">READ_COMMITTED</code></th>\n<th><code class=\"language-text\">REPEATABLE_READ</code></th>\n<th><code class=\"language-text\">SERIALIZABLE</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">@Version</code> Only</td>\n<td><strong>A</strong></td>\n<td><strong>A</strong></td>\n<td><strong>B</strong></td>\n<td><strong>B</strong></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">OPTIMISTIC</code></td>\n<td><strong>A</strong></td>\n<td><strong>A</strong></td>\n<td><strong>B</strong></td>\n<td><strong>B</strong></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">OPTIMISTIC_FORCE_INCREMENT</code></td>\n<td><strong>A</strong></td>\n<td><strong>A</strong></td>\n<td><strong>B</strong></td>\n<td><strong>B</strong></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">PESSIMISTIC_READ</code></td>\n<td><strong>C</strong></td>\n<td><strong>C</strong></td>\n<td><strong>C</strong></td>\n<td><strong>C</strong></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">PESSIMISTIC_WRITE</code></td>\n<td>✔</td>\n<td>✔</td>\n<td><strong>D</strong></td>\n<td><strong>D</strong></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">PESSIMISTIC_FORCE_INCREMENT</code></td>\n<td><strong>E</strong></td>\n<td><strong>E</strong></td>\n<td><strong>E</strong></td>\n<td><strong>E</strong></td>\n</tr>\n</tbody>\n</table>\n<h3>AfterUpdate</h3>\n<ul>\n<li>A 트랜잭션 시작</li>\n<li>A 조회</li>\n<li><em><code class=\"language-text\">A 수정</code></em></li>\n<li><em><code class=\"language-text\">B 트랜잭션 시작</code></em></li>\n<li><em><code class=\"language-text\">B 조회</code></em></li>\n<li>B 수정</li>\n<li>A 트랜잭션 커밋</li>\n<li>B 트랜잭션 커밋</li>\n</ul>\n<blockquote>\n<p>PSQL 경합 테스트 결과, BeforeUpdate 와 AfterUpdate 의 결과가 동일하다.</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>LockType \\ Isolation Level</th>\n<th><code class=\"language-text\">READ_UNCOMMITTED</code></th>\n<th><code class=\"language-text\">READ_COMMITTED</code></th>\n<th><code class=\"language-text\">REPEATABLE_READ</code></th>\n<th><code class=\"language-text\">SERIALIZABLE</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">@Version</code> Only</td>\n<td><strong>A</strong></td>\n<td><strong>A</strong></td>\n<td><strong>B</strong></td>\n<td><strong>B</strong></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">OPTIMISTIC</code></td>\n<td><strong>A</strong></td>\n<td><strong>A</strong></td>\n<td><strong>B</strong></td>\n<td><strong>B</strong></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">OPTIMISTIC_FORCE_INCREMENT</code></td>\n<td><strong>A</strong></td>\n<td><strong>A</strong></td>\n<td><strong>B</strong></td>\n<td><strong>B</strong></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">PESSIMISTIC_READ</code></td>\n<td><strong>C</strong></td>\n<td><strong>C</strong></td>\n<td><strong>C</strong></td>\n<td><strong>C</strong></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">PESSIMISTIC_WRITE</code></td>\n<td>✔</td>\n<td>✔</td>\n<td><strong>D</strong></td>\n<td><strong>D</strong></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">PESSIMISTIC_FORCE_INCREMENT</code></td>\n<td><strong>E</strong></td>\n<td><strong>E</strong></td>\n<td><strong>E</strong></td>\n<td><strong>E</strong></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>A</strong> : <code class=\"language-text\">ObjectOptimisticLockingFailureException</code>\n<ul>\n<li>Row was updated or deleted by another transaction (or unsaved-value mapping was incorrect)</li>\n</ul>\n</li>\n<li><strong>B</strong> : <code class=\"language-text\">CannotAcquireLockException</code>\n<ul>\n<li>[ERROR: <strong>could not serialize access due to concurrent update</strong>] [update versioned_entity set created_date=?,sequence=?,version=? where id=? and version=?]; SQL [update versioned_entity set created_date=?,sequence=?,version=? where id=? and version=?]</li>\n</ul>\n</li>\n<li><strong>C</strong> : <code class=\"language-text\">CannotAcquireLockException</code>\n<ul>\n<li>[ERROR: <strong>deadlock detected</strong>\nDetail: Process 236 waits for ShareLock on transaction 906; blocked by process 237.\nProcess 237 waits for ShareLock on transaction 905; blocked by process 236.\nHint: See server log for query details.\nWhere: while updating tuple (0,53) in relation \"simple_entity\"]\n[update simple_entity set created_date=?,sequence=? where id=?];\nSQL [update simple_entity set created_date=?,sequence=? where id=?]</li>\n</ul>\n</li>\n<li><strong>D</strong> : <code class=\"language-text\">CannotAcquireLockException</code>\n<ul>\n<li>[select se1_0.id,se1_0.created_date,se1_0.sequence from simple_entity se1_0 where se1_0.id=? <strong>for no key update</strong>]\n[ERROR: <strong>could not serialize access due to concurrent update</strong>] [update versioned_entity set created_date=?,sequence=?,version=? where id=? and version=?]; SQL [update versioned_entity set created_date=?,sequence=?,version=? where id=? and version=?]</li>\n</ul>\n</li>\n<li><strong>E</strong> : <code class=\"language-text\">PessimisticLockingFailureException</code>\n<ul>\n<li>[select ve1_0.id,ve1_0.created_date,ve1_0.sequence,ve1_0.version from versioned_entity ve1_0 where ve1_0.id=? <strong>for no key update nowait</strong>] [ERROR: could not obtain lock on row in relation \"versioned_entity\"]</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"[PSQL] 트랜잭션 정합성 테스트","date":"April 19, 2025","description":null}},"previous":{"fields":{"slug":"/2025.02/2025.02.22/"},"frontmatter":{"title":"[Kotlin] Kotlin JDSL 삽질 일기"}},"next":null},"pageContext":{"id":"ae3b729d-cded-573c-8a3b-338cba2fd6c8","previousPostId":"61822c23-7497-563a-bf5b-dd64280e3fdc","nextPostId":null}},"staticQueryHashes":["2841359383","3257411868"],"slicesMap":{}}